{
  "title": "Apr 24",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; white-space: normal;\"><div>{</div><div>vector &lt;MyString&gt; v;</div><div><br/></div><div>v.push_back(“abc”);</div><div>cout  &lt;&lt; v[0];</div><div>}</div><div><br/></div><div><ul><li>other template classes:</li><ul><li>deque</li><ul><li>stands for double ended queue</li><li>behaves the same way as vector, except it’s FIFO</li><li>Constant time insertion on both ends</li></ul><li>vector container guarantees that underlying data is allocated in a contiguous array. Deque doesn’t make this guarantee.</li><li>list</li><ul><li>does not have [] operator</li><li>list is a linkedlist</li><li>list&lt;MS&gt; v; v.push_back(“abc”);</li><li>Each node object has both next and previous pointers, so it’s a doubly linkedlist</li><li>List class has head and tail pointers pointing to the first and last nodes.</li><li>Templates allow us to embed the actual data type into the node, and the node doesn’t hold some pointer to the data. (recall C implemented linkedlist has a void*)</li></ul></ul></ul><div><br/></div></div><div>IN C++ containers, items are held by value, not by pointer. This is called by-value semantics</div><div><br/></div><div><br/></div><div>Linkedlist is good when you put things in the middle</div><div>Array-based containers are bad when you put things in the middle</div><div><b>but time complexity doesn’t tell us which is better.</b> </div><div>vector is cache friendly, because everything is contiguous</div><div>Linkedlist is not cache friendly </div><div><ul><li>vector often wins, despite worse time complexity</li></ul><div><br/></div><div>There is no way to theoretically ascertain the performance of every container.</div></div><div><br/></div><div><br/></div><div>{</div><div>MS s(“abc”);</div><div>string s2(“xyz”); </div><div>cout &lt;&lt; s2 &lt;&lt; endl;</div><div>s2[0] == ‘A’;</div><div><ul><li>string class has tons of features</li></ul></div><div>}</div><div><br/></div><div><hr/></div><div><br/></div><div>template &lt;typename I, typename F&gt;</div><div>void for_each (I b, I e, F f){</div><div><span>    while (b!=e){</span><br/></div><div><ul><li>if you wrote b&lt;e, it wouldn’t work for linkedlist. linkedlist is not contiguous.</li><li>But every iterator has a != operator</li></ul></div><div><span><span>    <span>    f(*b);</span></span></span></div><div><span><span><span><span>    <span>    ++b;</span></span><br/></span></span></span></div><div><ul><li>in template programming, ++b is preferred to b++</li><li>for b++, you have to return the state of b before the increment, and so you’d have to make a copy. totally unnecessary</li></ul></div><div><span><span>    </span>}</span></div><div>}</div><div>////////////////</div><div>{</div><div><span>    </span>int a[5] ={100,101,102,103,104}; </div><div><span>    </span>for_each(a, a+5, print);</div><div><ul><li>a is interpreted as int *</li><li>print is function pointer: void (*)(int)</li></ul></div><div>}</div><div><br/></div><div>{</div><div>vector &lt;MS&gt; v;</div><div>v.push_back(“abc”);</div><div>…</div><div><br/></div><div>for_each(v.begin(), v.end(), print ); </div><div><ul><li>begin() gives you an iterator object. an iterator is a pointer wannabe. it tries to behave like a pointer as much as possible. </li><li>You can do ++ on an iterator to move the iterator to the next object in the container. </li><li>v.begin() gives back a <b>vector iterator</b>. different operators like ++, * ..etc are defined in its class.</li><li>the iterator is a nested class inside the vector class.      vector &lt;MS&gt;::iterator i,j;</li><li><br/></li></ul></div><div>}</div><div><br/></div><div>void print (int x){</div><div><span>    cout &lt;&lt; x &lt;&lt; endl; </span><br/></div><div>}</div><div><br/></div><div><br/></div><div><br/></div><div><b>STL: standard template library. Basically refers to the C++ standard library.</b></div><div><b><br/></b></div><div>typedef T* iterator;</div><div><ul><li>if you do this, it works for vector, since contiguous</li><li>but this doesn’t work for LinkedList</li></ul><div><br/></div></div><div><b>You want template code to work EVERYWHERE. </b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div>Forward iterators can do ++</div><div>Bidirection iteartor can do ++ or --</div><div><ul><li><b>for linkedlist.</b></li></ul><div>Rangdom Access Iterator</div></div><div><ul><li>you can also iterate through []</li><li>you can also compare &lt; &gt;</li></ul></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><br/></div></div>"
    }
  ]
}
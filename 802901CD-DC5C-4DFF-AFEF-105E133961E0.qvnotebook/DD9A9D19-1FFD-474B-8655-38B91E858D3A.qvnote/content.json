{
  "title": "Mar 23 Recitation",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; white-space: normal;\"><div>Process is a running instance of a program</div><div><br/></div><div>Parent and child would not affect eachother — the child’s memory space is <span style=\"font-style: italic;\">cloned. </span></div><div><br/></div><div>exec — has a bunch of different variants. Allows you to modify the instance after forking. The variants are different ways to do this. read more man exec. <span style=\"font-weight: bold;\">the only version that you need is execl.</span></div><div><br/></div><div>After execl, the memory location for the child process will be wiped and then replaced with the relevant information.</div><div><ul><li>the following portion of code SHOULDN’T be executed, otherwise it wouldn’t be working. That’s why you know it failed if the code continues to the line after execl.</li></ul><div><br/></div></div><div>The parent is the one responsible for the child.</div><div><br/></div><div><br/></div><div>zombie if it terminates but the parent hasn’t called wait or wait pid. The zombie gets adopted.  <span style=\"font-weight: bold;\">remember to call wait or waitpid if you fork.</span></div><div><br/></div><div><span style=\"font-weight: bold;\">You would still have to call free() when you run malloc in the child process. Regardless of whether parent waits or not. </span></div><div><br/></div><div>fork returns the pid of the child. If you’re in the child, it’s 0.</div><div><br/></div><div><input type=\"checkbox\" checked=\"false\"/><span style=\"font-weight: bold;\">read emma’s email about drawing fork diagrams. </span><br/></div><div><b/><br/></div><div><br/></div><div><br/></div><div><br/></div><div>waitpid(pid, NULL, 0)</div><div><ul><li>first arg: can set as -1 to wait for any child</li><li>second arg: status</li><li>third arg: 0 means parent gets suspended. </li></ul><div><br/></div></div><div><br/></div><div>If Process1 forks Process2</div><div>and process1 doesnt’ wait for process2</div><div>then there isn’t any guarantee who finishes first.</div><div><br/></div><div><br/></div><div> </div><div><br/></div></div>"
    }
  ]
}
{
  "title": "Apr 26",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; white-space: normal;\"><div><b>Smart pointers</b></div><div><b><br/></b></div><div>{</div><div>Foo b;</div><div><ul><li>creates the object on the stack</li></ul></div><div>b = a.createFoo();</div><div>b.doSomething();</div><div>return b; </div><div>}</div><div><br/></div><div>in java, class objects are pointers to memory locations. </div><div><br/></div><div><br/></div><div>SmartPtr</div><div><table style=\"border-collapse: collapse; min-width: 100%;\"><colgroup><col style=\"width: 130px;\"/></colgroup><tbody><tr><td style=\"border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;\"><div>Foo *</div></td></tr><tr><td style=\"border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;\"><div>Int *</div></td></tr></tbody></table><div><br/></div></div><div><br/></div><div>{</div><div><span>    SmartPtr&lt;Foo&gt; b;</span><br/></div><div><ul><li>acts like a pointer</li><li>will take care of deallocating the thing for you</li><li>you don’t want a copy of this huge object, just a pointer,<b> but a pointer that takes care of deallocation.</b></li></ul></div><div><span><span>    b = a.createFoo();</span><br/></span></div><div><span>    b -&gt; doSomething(); </span><br/></div><div><span><span>    return b;</span><br/></span></div><div>}</div><div><br/></div><div><br/></div><div>Reference counting: </div><div><br/></div><div>{</div><div>SP &lt;Foo&gt; p (new Foo());</div><div><ul><li>new Foo() returns a pointer to an object on the heap</li><li>pointer within SP&lt;Foo&gt; (on stack) points to this object</li><li>When p goes out of scope, the destructor is supposed to delete p’s data</li><li>Allocates a 4byte integer on the heap, value 1</li></ul><div>Sp &lt;Foo&gt; p2 ( p );</div><div><ul><li>pointing to the same object as p, the object doesn’t get copied</li><li>int * would point to the same location as p’s int*, but you increment the number</li><ul><li>during destructor, it will decrement and check the int*, and see what number it is. if it’s 0, then it destructs. Otherwise nothing</li></ul></ul></div></div><div><br/></div><div>inspectFoo(p2);</div><div><br/></div><div>}</div><div><br/></div><div>void inspectFoo(SP &lt;Foo&gt; q){</div><div><span>    q-&gt;inspect();</span><br/></div><div><span>    q-&gt;print();</span><br/></div><div><span><span>    return;</span><br/></span></div><div>}</div><div><br/></div><div><br/></div><div><br/></div><div><b>share_ptr&lt;Foo&gt;</b></div><div><ul><li>This is the class in C that does the job of smartpointer</li></ul><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>explicit — tells compiler not to do promotion using this constructor</div><div><br/></div><div><br/></div><div>SmartPtr(const SmartPtr&lt;T&gt; &amp; sp)</div><div><span>    </span>:ptr(sp.ptr), count(sp.count)</div><div><ul><li>initializes member variables as what’s inside the ()</li><li>If these work class variables and they weren’t initialized here, compiler would construct it using default construct, and then inside the curly braces would use copy construction to replace them with what’s passed into SmartPtr’s constructor</li><li>this code calls copy construction to begin with, so that no overwriting of default construction is needed.</li></ul></div><div>{</div><div><span>    ++*count;</span><br/></div><div>}</div><div><br/></div><div>~SmartPtr(){</div><div><span>    if (—*counter == 0 ){</span><br/></div><div><ul><li>decrement first, check second</li></ul></div><div><span><span>    <span>    delete count;</span></span></span></div><div><span><span><span><span>    <span>    delete ptr;</span></span><br/></span></span></span></div><div><span><span>    </span>}</span></div><div>}</div><div><br/></div><div><br/></div><div><br/></div><div>// allows if (sp) … this would break if you don’t have the following operation, since you’re not checking if a <i>pointer</i> is null.</div><div>operator void*() const {return ptr;}</div><div><ul><li>using void* to limiting utility of operation to only &quot;if (sp) …”</li><li>any pointer can be assigned to void*, so it’s automatic, no casting needed</li></ul></div><div><br/></div><div><br/></div></div>"
    }
  ]
}
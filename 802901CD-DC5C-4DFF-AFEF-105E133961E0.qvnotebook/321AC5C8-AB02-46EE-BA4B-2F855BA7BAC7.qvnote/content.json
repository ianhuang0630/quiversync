{
  "title": "Jan 25",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; white-space: normal;\"><div>For an 8 bit integer</div><div>2^8 distinct values</div><div>Range:</div><div><ul><li>0 - 2^8-1 (For <span style=\"font-weight: bold;\">unsigned</span>)</li><li>-128 to 127 (-2^7 to 2^7-1)</li></ul></div><div><br/></div><div>For signed:</div><div>The first bit corresponds to a negative weight.</div><div>Because it has the most weight, even if all the other places are 1’s, the number is still negative.</div><div><br/></div><div><br/></div><div><br/></div><div>binary 1111 1111 1111 1111 11111 1111 1111</div><div>decimal -1    -1      -1      -1     </div><div>hex:      F       F       F        F </div><div><br/></div><div>0xFFFF is 1111 1111 1111 1111 in binary</div><div>0x7FFFFFFF = 2^31 - 1 in decimal</div><div>0x80000000 = 1000 000 …. in binary = -2^31 in decimal</div><div><br/></div><div>in c, 0x123 — a hex number</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>For a binary number</div><div><ul><li>Flip the bits and add 1 to the least significant digit, and that’s the negative.</li><li>e.g 5 =  0101 -&gt; 1010 -&gt; 1011 = -5</li></ul></div><div><br/></div><div><hr/><div><span style=\"font-size: 36px; font-weight: bold;\">C</span></div></div><div><br/></div><div><font style=\"font-size: 24px;\">char x = 65; </font></div><div><font style=\"font-size: 24px;\">char x = ‘A’; // this is a number</font></div><div><br/></div><div>There is a slight type mismatch — but it’s ok converting 4-byte to 1-byte</div><div>Why is ‘A’ 65?</div><div><ul><li>The number corresponding to the symbol is in the ASCII table</li><ul><li>ASCII maps all symbols to integers in range [0-127] (1 byte)</li><li>encoding — encoding 4 byte unicode characters . If first bit is 0, then it’s ascii. if it’s 1, then you look at the next bit, and it tells you waht sort of character it is (It’s called <b>UTF-8</b>)</li></ul><li>‘A’ is of type Int, and the value is 65</li><li>‘A’ + 1 = 66</li></ul><div><br/></div></div><div>Some variations on what can go into the single quote:</div><div><ul><li>y = ‘\\n’ is value 10</li><ul><li>ascii table mapping for new line character. (non-printable character)</li></ul><li>y = ‘\\t’</li><li>y = ‘\\\\’ - single backslash</li><li>y = ‘\\13’ — interpreted as an octal number (which would be 11 in decimal)</li><li>y = ‘\\0’ - equivalent to 0</li><ul><li>‘\\0’ != ‘0’</li><ul><li>first one isn’t looked up in ascii because it’s an octal</li><li>second is looked up in ascii</li></ul></ul></ul></div><div><br/></div><div>UNIcode - 4 bytes long </div><div><ul><li>all existing symbols</li></ul><div><br/></div></div><div><br/></div><div><font style=\"font-size: 24px;\">double x = 3.14;</font></div><div>COMPLETELY different format from char</div><div><br/></div><div><br/></div><div><span style=\"font-size: 24px;\">float x = 3.14f;</span></div><div>if done without the f, it should still work for most case, because it converts double —&gt; float</div><div>but this can be troublesome if longer decimal digits are first interpreted as a double and then converted into the float</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>Expression - has a type and a value.</div><div><ul><li>e.g. 65</li><li>e.g. ‘A’  </li><li>e.g ‘\\0’</li><li>e.g. foo() - type is function call, value is whatever foo returns</li></ul><div><br/></div></div><div>All expressions are statements if added ; at the end</div><div><br/></div><div>statements that are also expressions:</div><div><ul><li>e.g. int x;</li><ul><li>statement declares the variable </li></ul><li>x = 1;</li><ul><li>statement assigns the number 1 to x.</li><li>It is also an<b> expression. the value of this expression is 1. </b>The value of a = assignment is the value of the L-value (the value after assignment on the left side of the =). </li></ul><li>y = x = 1</li><ul><li>because of associativity, y = x=1 is equivalent to y = (x = 1);</li><ul><li>x = 1 MUST have a value, otherwise, there can’t be anything assigned to y</li></ul></ul><li>x = x+1</li><ul><li>evaluate the righthand side expression (expression x+1 value is 2 if x started off as 1)</li><li>expression value is 2 if x started off as 1</li><li>x += 1 or ++x</li></ul><li>x = 1; x++; (post-fix increment x)</li><ul><li>the Value of the expression is different than ++x</li><li>the value of this expression is the value of x before incrementation</li><li>e.g. x= 1;  y = x ++;</li><ul><li>x would become 2</li><li>y would become 1 </li></ul><li>It is <b>both a statement and an expression.</b></li><li>The value of x++ has nothing to do with what happens to x </li></ul></ul></div><div><br/></div><div>+ has higher precedence than equals, so you can’t do y = 1+x = 1;</div><div><br/></div><div><br/></div><div><font style=\"font-size: 24px;\">Operations </font></div><div><br/></div><div>x = 1;</div><div>y = x &lt;&lt; 1; // this is a bit shift. </div><div><br/></div><div><br/></div><div>000000 … 0001 —&gt; 0000000 … 0010</div><div><br/></div><div><br/></div><div><ul><li>value of x after will still be 1 — it doesn’t change!</li><ul><li>if you want x to change, you have to write</li><ul><li>x &lt;&lt;= 3</li></ul></ul><li>y becomes 2. y = x &lt;&lt; 3; would multiply x by 2^3 and assign it to  y. X DOES NOT CHANGE. Value of the operation is 8</li></ul><div><br/></div></div><div>x =1 ;</div><div>y = x &gt;&gt; 3;</div><div><ul><li>If you had 1 at the MSD to begin with, the negative sign will be preserved.</li><li>If you had 1 at the LSD, then it falls off and disappears</li></ul><div><br/></div></div><div><br/></div><div>x = 1;</div><div>y = 2; </div><div>z = x|y;</div><div><ul><li>00000000…0001 or 00000…000010</li><li>bitwise or gives</li><li>000000…00011</li><li>z becomes 3</li></ul><div><br/></div><div>z = x&amp;y;</div></div><div><div><ul><li>gives 000000…0000 = 0 in decimal</li><li>z becomes 0 </li></ul><div><br/></div></div><ul/></div><div><ul/></div><div><br/></div><div><b>int foo(int a){</b></div><div><span><b>    return a &amp; 0x000000000f;</b></span></div><div><b>}</b></div><div><ul><li>0…00000001111                     0x000000000f<br/></li><li>This code basically kills everything except the last four bits, and keeping the last four as is.<br/></li><li>( also This is taking the remainder and dividing by 16 — the last 4 bits encode for 16)</li></ul></div><div> </div></div>"
    }
  ]
}
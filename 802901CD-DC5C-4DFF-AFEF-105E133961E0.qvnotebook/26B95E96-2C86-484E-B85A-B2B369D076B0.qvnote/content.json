{
  "title": "Apr 17",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; white-space: normal;\"><div>foo(){</div><div>    MyString S1(“abc”); </div><div>    MyString S2(“def”);</div><div>    MyString S3;</div><div>    S3 = S1+S2;</div><div>}</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>MyString::MyString (const char *p){</div><div>    if ℗{</div><div>        len = strlen℗;</div><div>        data = new char [len+1];</div><div>        strcpy(data, p); </div><div>    }else{ // if MyString S3(NULL);</div><div>        data = new char[1];</div><div>        data[0] = ‘\\0’;</div><div>        len = 0;</div><div>    }</div><div>}</div><div><br/></div><div>MyString::~MyString(){</div><div>    delete [] data; // somethign that we allocated on the heap</div><div>}</div><div><br/></div><div><br/></div><div><br/></div><div><span style=\"font-weight: bold;\">RAII -resource allocation is initialization</span></div><div>acquiring resources and releasing during construction and deconstruction. Lets the automatic destruction call deal with freeing resources.</div><div><br/></div><div>bar(S1)</div><div><br/></div><div>void bar(MyString s){</div><div>    cout &lt;&lt; s &lt;&lt; endl; </div><div>}</div><div><br/></div><div>Stack of bar:</div><div><br/></div><div>S </div><div><div><br/></div><table style=\"border-collapse: collapse; min-width: 100%;\"><colgroup><col style=\"width: 130px;\"/></colgroup><tbody><tr><td style=\"border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;\"><div>pointer to location of string in the heap</div></td></tr><tr><td style=\"border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;\"><div>length: 3 </div></td></tr></tbody></table><div>Right before you get out of the bar scope (when bar returned), destructor deletes the string memory in the heap</div></div><div>then when you exit out of the main look, destructor tries to delete the string memory again — this crashes the program.</div><div><br/></div><div>As such, each instance of a string class must own its own string heap allocation. This means that the copy must be a <span style=\"font-weight: bold;\">deep copy</span>. You need to write a copy constructor in the str class.</div><div><br/></div><div>MyString::MyString(const MyString&amp; s)</div><div>{</div><div>    len = s.len;</div><div>    data = new char[len+1];</div><div>    strcpy(data, s.data); </div><div>}</div><div><br/></div><div><br/></div><div>MyString&amp; MyString::operator=(const MyString&amp; rhs){</div><div>    // prevents against deleting your own data</div><div>    if (this == &amp;rhs){</div><div>        return *this;</div><div>    }</div><div><br/></div><div>    // clearing out data that <span style=\"font-weight: bold;\">this </span>used to hold</div><div>    delete [] data;</div><div><br/></div><div>    len = rhs.len;</div><div>    data = new char[len +1];</div><div>    strcpy(data, rhs.data);</div><div><br/></div><div>    return *this;   </div><div>}</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>If you define member function instead of just declaring it, you tell compiler to in-line this function. Only makes sense for short functions.</div><div><br/></div><div>int length() const {</div><div><ul><li>promises that this member function is not going to modify <span style=\"font-weight: bold;\">this</span> object.</li><li>If you tried to change this-&gt;len = 57, it will not compile because you promised that it won’t change anything</li></ul></div><div>    return len;</div><div>}</div><div><br/></div><div><span style=\"font-weight: bold;\">you want to use const for member functions that doesn’t modfiy the internal state for the homeworks.  </span></div><div><span style=\"font-weight: bold;\">With const as an argument for a method , no need for copy construction.</span></div><div><br/></div><div><br/></div><div>MyString operator+(const MyString&amp; s1, const MyString&amp; s2){</div><div><ul><li>this is not a member function</li><li>but how can this access .data and .len?</li><li>“friend MyString operator+(…)” in the class .h — “invites a friend to touch the private parts &quot;</li></ul></div><div>    MyString temp;</div><div>    delete[] temp.data;</div><div><ul><li>removing that one byte ‘\\0’ </li></ul><div>    temp.len = s1.len + s2.len;</div></div><div>    </div><div>    temp.data = new char[temp.len+1];</div><div>    strcpy(temp.data, s1.data);</div><div>    strcat(temp.data, s2.data);</div><div>    return temp;</div><div><ul><li>return by value — this is a copy</li></ul></div><div>}</div><div><ul><li>if you return by reference, this will be a reference to a local variable that’s going away outside the scope of the method</li></ul></div><div><br/></div><div>s3 = s1+s2;</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style=\"font-weight: bold;\">This is in the sample code. </span></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style=\"font-weight: bold;\">s1+”world”</span></div><div><ul><li>mystring + char*</li><li>but mystring has a constructor that takes a char*</li><li>compilor constructs a temporary myString</li></ul><div><br/></div></div><div>good rule of thumb: if the operator is symmetric, then this should be a global friend function. (e.g. +)</div><div><br/></div><div><br/></div><div><br/></div><div>char&amp; operator[](int i );</div><div><br/></div><div>char&amp; MyString::operator[](int i){</div><div>    return data[i]; </div><div>}</div><div><ul><li>char&amp; allows you to write into it too. that’s why it’s char&amp; and not just returning by value.</li></ul></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div>"
    }
  ]
}
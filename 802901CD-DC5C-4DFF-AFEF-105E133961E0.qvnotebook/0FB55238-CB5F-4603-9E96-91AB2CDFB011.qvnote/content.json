{
  "title": "Apr 12",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; white-space: normal;\"><div>memory allocation for objects in C vs. C++ </div><div><br/></div><div>int main(){</div><div><span>    </span>Pt *p2 = new Pt();</div><div><ul><li>new is malloc followed by constructor call</li><li>new calls a function that malloc calls</li></ul><div><br/></div></div><div><br/></div><div><br/></div><div><span>    delete p2;</span><br/></div><div><ul><li>delete is a keyword, so &quot;delete (p2)&quot; also works</li><li>equivalent to destructor and then free</li></ul></div><div>}</div><div><br/></div><div><br/></div><div>when mallocing, constructor is not invoked</div><div>You must also cast the malloc:</div><div>Pt *p2 = (Pt *) malloc (sizeof(Pt));</div><div><br/></div><div><br/></div><div>in C:</div><div>Pt *p3 =  malloc(sizeof (Pt) * 100);<br/><ul><li>you get a pointer pointing to an array of 100 Pt objects</li></ul><div><br/></div><div><br/></div><div>in C++</div></div><div>Pt *p3 = new Pt[100];</div><div><ul><li>this creates a pointer pointing to an array of 100 Pt objects</li><li>For each of the objects, constructor is getting called</li></ul><div><br/></div></div><div>delete [] p3;</div><div><ul><li>if p3 points to an array of objects, you have to put []</li><li>Otherwise program will crash</li></ul><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>MyString s1 = “abc”;</div><div><ul><li>this is equivalent to MyString s1 (“abc”)</li></ul></div><div>MyString s2 = “def”;</div><div>MyString s3;</div><div>s3 = s1+s2;</div><div><br/></div><div><b>NOTE: MS = MyString</b></div><div>class MyString{</div><div><span>    char *data;</span><br/></div><div><span><span>    int len;</span><br/></span></div><div><span><span><span>    </span><br/></span></span></div><div>    // <b>the basic 4</b><br/></div><div><span>    mystring (const char *); // constructor</span></div><div><span><span><span>    ~MS (); // destructor</span></span></span></div><div><span><span><span><span>    MS(const MS&amp;);</span><br/></span></span></span></div><div><ul><li>if not written, it would just write one for you : copy constructor</li></ul></div><div><span><span><span><span><span>    MS&amp; operator =(const MS&amp;);</span><br/></span></span></span></span></div><div><ul><li>if not written, it would just write one for you</li></ul></div><div>}</div><div><br/></div><div>[data] ——&gt; [‘a'][‘b'][‘c’][0] (must be on heap , since you want it to be mutable. Otherwise, it’d be in the code region)</div><div>[ len ] </div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>The proper way to define methods:</div><div>put the prototype in a .h file (declare methods, but don’t define)</div><div>define the function (implement it) in the cpp file</div><div><br/></div><div>MyString::MyString(const char *s){</div><div><div><ul><li>this is how you write a constructor</li><li>MyString::Mystring shows that this is the constructor for a mystring class</li></ul><div><br/></div></div><div><span>    len = strlen(s);</span><br/></div><div><span><span>    // data = malloc (len + 1); </span><br/></span></div><div><span><span><span>    data = new char[len+1];</span><br/></span></span></div><div><ul><li>these these things are equivalent</li></ul></div><div><span><span><span><span>   </span><br/></span></span></span></div><span>    strcpy(data, s);</span><br/><div><br/></div><ul/></div><div>}</div><div><br/></div><div><br/></div><div>MyString::MyString(const char *s){</div><ul><li>this is how you write a constructor</li><li>MyString::Mystring shows that this is the constructor for a mystring class</li></ul><div><br/></div><div>    len = 0);</div><div>    data = new char[1];   </div><ul/><div><span>    *data = 0;</span><br/></div><div>}</div><div><br/></div><div>MyString::~Mystring(){</div><div><span>    delete [] data;</span><br/></div><div>}</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>Destructors are good because they handle the memory for you. The compiler calls it, and it gets called after every error</div><div>You wouldn’t have to manually code it.</div><div><br/></div><div><br/></div><div><br/></div></div>"
    }
  ]
}
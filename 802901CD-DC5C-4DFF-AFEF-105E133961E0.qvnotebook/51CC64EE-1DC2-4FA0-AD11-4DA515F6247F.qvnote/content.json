{
  "title": "Mar 22",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; white-space: normal;\"><div>The exam is cumulative. Everything done (including today) is fair game</div><div>Expected to know fork and exec well</div><div><br/></div><div><b><font style=\"font-size: 24px;\">Sockets API</font></b></div><div><hr/></div><div><br/></div><div>What did netcat do in its source code?</div><div><br/></div><div><a href=\"http://beej.us/guide/bgnet\">http://beej.us/guide/bgnet</a></div><div><ul><li>online textbook for the sockets API portion</li><li>though everything that you have to know will be in the code and notes and slides (available on course homepage)</li></ul><div><br/></div></div><div><br/></div><div>one end of an established connection is a connected socket. </div><div>2 ip addresses and 2 port numbers uniquely define a pair of connected sockets</div><div>Socket is bound to an IP address and a port number </div><div><br/></div><div><br/></div><div>The API</div><div>Client:</div><div><ul><li>socket()</li><ul><li>create the client end of the connection</li></ul><li>connect()</li><ul><li>connect to a server. Sends a connect request</li><li>Once the server accepts, then you can start communicating</li></ul><li>send()</li><ul><li>send data to the remote party</li></ul><li>recv()</li><ul><li>receive data from the remote party</li></ul><li>close()</li><ul><li>sends an EOF to read() on remote side.</li></ul></ul></div><div>Server:</div><div><ul><li>socket(domain, type, protocol)</li><li>bind(server_sock, &amp;server_address, server_len)</li><ul><li>you pass a address structure which has a port number and its own ip address</li><li>You have to pass an ip address because you usually have multiple ip addresses</li><li>ip address are 4 numbers separated by .’s New ip is a 4 byte integer</li><li>0.0.0.0</li><ul><li>not a valid address. Reserved to mean “any of my interfaces”</li><li>all of my interfaces will listen on port number …</li></ul></ul><li>listen(server-sock, backlog)</li><ul><li>backlog is a number — how many simultaneous connection requests is the system supposed to queue up?</li><ul><li>How many simultaneous requests can be waiting while the server is not processing any of them?</li></ul><li>this is when the waiting starts</li></ul><li>accept(server_sock, &amp;client_addr, &amp;client_len)</li><ul><li>would make <b>one </b>connection with a client</li><li>only if the server calls accept will the client request be accepted</li><li>it will actually create a new socket — NOT THE SAME ONE AS THE ONE YOU GET AFTER CALLING SOCKET — and that socket is passed to accept</li><ul><li>the first “<b>listening</b>” socket is passed to bind and listen</li><li>but the new socket is what’s connected to the client. This is the socket you use to read and receive and communicate</li></ul><li><br/></li></ul><li>read() (same as recv)</li><ul><li>will return EOF if client closes.</li><ul><li>note; <b>a server can close a connection first too.</b></li></ul></ul><li>close()</li></ul><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><b>in tcp-sender.c</b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><ul><li>the sender will first send 4 bytes fo the size of the file its going to receive</li><li>then the client will send the file content</li><li>The server will send the number of bytes received. Client checks that it matches.<br/></li></ul><div><br/></div></div><div>TCP doesn’t require size of file to be sent. THIS IS NOT TCP.</div><div>TCP only gives you the clean pipe. What you do with it (your own protocol) is completely up to you.</div><div><br/></div><div><br/></div><div><br/></div></div>"
    }
  ]
}
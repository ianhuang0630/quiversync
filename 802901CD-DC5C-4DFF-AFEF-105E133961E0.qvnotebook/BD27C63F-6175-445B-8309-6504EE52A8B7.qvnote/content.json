{
  "title": "Feb 27",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; white-space: normal;\"><div>Lecture note 9</div><div><br/></div><div>standard IO: 3 channels</div><div><ul><li>stdin (standard input):</li><ul><li>incoming character stream, normally from keyboard</li></ul><li>stdout (standard output):</li><ul><li>outgoing character stream, normally termianl screen</li><li>buffered until new line comes or buffer is filled</li></ul><li>stderr (standard error):</li><ul><li>outgoing character stream, normally terminal screen</li><li>unbuffered</li></ul></ul><div><br/></div></div><div><br/></div><div>$ vim input </div><div><br/></div><div>$ cat input</div><div>20</div><div><br/></div><div>$ ./a.out  &lt;   input </div><div><ul><li>redirecting stdinput to “input”</li><li>It will never ask the user for a number</li></ul><div><br/></div></div><div>$ ./a.out &gt;  outputfile</div><div><ul><li>this will paste the output of the terminal into “outputfile”</li><li>This will override outputfile if it already exists. </li><ul><li>If you dont’ want this behavior, you can do:</li><ul><li>./a.out &gt;&gt; outputfile</li></ul></ul><li>User input still needed because no input file given</li></ul><div><br/></div></div><div>$ ./a.out &lt; input &gt; outputfile</div><div><ul><li>No user input needed</li><li>You are telling the bash shell to rearrange standard input and output so that it comes from input and goes to outputfile without the .c file knowing.</li></ul><div><br/></div></div><div>$ valgrind --leak-check=yes ./a.out &lt; input &gt;&gt; outputfile  2&gt;errfile</div><div><ul><li>valgrind error message goes to errfile</li></ul><div><br/></div></div><div><div>$ valgrind --leak-check=yes ./a.out &lt; input &gt;&gt; outputfile  2&gt;&amp;1</div><ul><li>2&gt;&amp;1 redirect the output channel of error to the outputfile</li></ul><div><br/></div></div><div><br/></div><div>$ echo adsfasdf</div><div>adsfasdf</div><div><br/></div><div>$ echo 5 | ./a.out </div><div><ul><li>feeding 5 into ./a.out</li><li>| is called a pipe</li><li>the type awareness is in the code, at this point it doens’t know what type “5” is</li></ul><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div>head - see the first 10 lines of an output</div><div>tail - see the bottom 10 lines of an output</div><div><br/></div><div><br/></div><div><br/></div><div>grep </div><div><ul><li>you can give regular expressions</li></ul><div><br/></div></div><div><br/></div><div>cut -f 1 -d “ ”</div><div><ul><li>-f field</li><li>-d delimiter</li></ul><div><br/></div></div><div>sed ’s/OLD/NEW/‘</div><div><ul><li>Subsituting an old pattern with a new pattern</li></ul><div><br/></div></div><div>sed ’s/$/@columbia.edu/‘</div><div><ul><li>$ allows you to append at the end of the line</li></ul></div><div><br/></div><div>for i in ‘cat vimusers’; do echo $i; done</div><div><div><ul><li>echhoing all lines in vim users</li></ul></div></div><div><br/></div><div>for i in ‘cat vimusers’; do mutt -s “spam from ap” $i &lt; isort.c ; done</div><div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div>int printf(const char *format, …)</div><div><ul><li>depends on whether and which %d/s/p…etc’s</li><li>Called variadic functions</li></ul><div><br/></div></div><div><br/></div><div>int sprintf(char *output_buffer, const char *format, …)</div><div><ul><li>write to output_buffer, and not printing in std output</li><li>You can do integer to string conversion</li></ul><div>int snprintf(char *output_buffer , size_t size, const char *format, … )</div></div><div><ul><li>safer version, checks buffer size and makes sure that it’s not overflowing</li></ul></div><div><br/></div><div>int sscanf(const char *input_string, const char *format, …)</div><div><ul><li>reading from a string, not standard input</li></ul><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>fprintf() &amp; fscanf()</div><div><ul><li>first argument for both are FILE *file</li><li>fprintf(…) = printf(stdout, …)<br/></li></ul><div><br/></div></div><div>stderr, stdin, stdout</div><div><div><ul><li>these are global variables already defined for you </li></ul><div><br/></div><div>exit (1)<br/></div><div><ul/></div><div><br/></div></div><div><br/></div><div><br/></div><div>FILE *fopen(const char *filename, const char *mode)</div><div><ul><li>called when you’d like to start using a file</li><li>mode can be r for reading, w for writing, a for appending</li><ul><li>r - must exist already</li><li>w - will trash existing file</li><li>a - will append</li><li>r+ - primarily reading but can also write</li><li>w+ - primarily writing (will trash existing file) but can also read<br/></li><li>a+ - primarily append but also read</li></ul></ul><div><br/></div></div><div>fopen does the book keeping and returns a pointer to a block of memory that remembers the content of the file</div>FILE * is passed between functions</div><div>the structure that it points to is machine dependent<br/><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>perror(filename);</div><div><ul><li>it would print out the filename</li><li>then colon</li><li>then whatever latest error message</li></ul><div><br/></div></div><div><br/></div><div>char *fgets(char *buffer, int size, FILE *file);<br/><ul><li>it reads at most size-1 characters into buffer, stoping if newline (\\n) is read, and terminating with \\0</li><li>returns NULL on EOF (end of file)<br/></li></ul><div><br/></div></div><div>printf([%4d], …)</div><div><ul><li>[   1], [  23] ..etc</li></ul><div><br/></div></div><div><br/></div><div>if (ferror(fp)){</div><div><div><ul><li>for fgets, a returned null can indicate that there was an error AS WELL AS it’s at the end of the file</li><li>ferror checks if it was an error or at the end of the file line</li></ul></div><ul/></div><div>}</div><div><br/></div><div><br/></div><div>fclose(fp);</div><div><ul><li>closes the file (what does that mean?)</li></ul><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><ul/></div><div><ul/></div><div><br/></div><div><br/></div><div><br/></div></div>"
    }
  ]
}
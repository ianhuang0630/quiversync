{
  "title": "Apr 19",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; white-space: normal;\"><div>void foo(const MyString&amp; s){</div><div><span>    cout &lt;&lt; s[0];</span><br/></div><div><span><span>    MyString S2(“ABC”);</span><br/></span></div><div><span><span><span>    </span><br/></span></span></div><div><span>    s[0] = ‘a’;</span><br/></div><div><ul><li>compiler would not let this happen. error will be returned</li><li>this is because you said in the method declaration that s is a const</li><li>because s is a const, compiler will call the <b>const </b>member function</li><li>the const member function returns a const char&amp;</li><li>const char &amp; = ‘a’ doesn’t make sense, because you are trying to change a const. </li></ul></div><div>}</div><div><br/></div><div>char&amp; operator[] (int i ){</div><div><span>    return data[i];</span><br/></div><div>}</div><div><ul><li>since a reference is returned, you can change it</li><li>s2[0] = ‘a’</li><li>if this returned just char, then it would return the value that’s inside, but s2[0] = ‘a’ would make no sense</li></ul><div><br/></div></div><div>const char&amp; operator[] const (int i ){</div><div>    return data[i];</div><div>}</div><div><ul><li>compiler will call the right method if two are offered, depending on what you want to do with [ ]</li></ul><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div>Lecture note 22</div><div><br/></div><div>int max(int x, int y) {</div><div><span>    if (x &lt; y) return y;</span><br/></div><div><span><span>    else return x;</span></span></div><div>}</div><div>double max(double x, double y) {</div><div>    if (x &lt; y) return y;</div><div>    else return x;</div><div>}</div><div><ul><li>in C, you can’t have fucntions of the same name</li><li>in C++ you can, but they must have different arguments</li></ul><div><br/></div></div><div>_____________________________________________________________</div><div><br/></div><div>//////////////////max.h//////////////////////</div><div>template &lt;typename T&gt;</div><div>const T&amp; max (const T&amp; x, const T&amp; y){</div><div><ul><li>instead of just T, we put const T&amp;, this saves the trouble of calling the copy constructor <br/></li></ul></div><div><span>   if (x&lt; y) return y ;</span></div><div><ul><li>this means that T must have a &lt; operator. must be defined for the class</li></ul></div><div><ul/></div><div><span><span>    else return x;</span><br/></span></div><div>}</div><div><ul><li>this is called a template</li><li>you include it in a header file</li><li>template itself is not code</li><li><br/></li></ul></div><div><br/></div><div>////////////////////foo.cpp///////////////</div><div># include &lt;max.h&gt;</div><div><br/></div><div>foo(){</div><div><span>    int x = max(100, 200);</span><br/></div><div><ul><li>won’t be able to find  a max that takes two integers</li><li>finds a template, where replace T with int, you end up with the right function that you can call</li><li>template instantiation happens </li></ul></div><div>}</div><div><br/></div><div><br/></div><div><br/></div><div>______________________________________________________________</div><div><br/></div><div>class IntArray{</div><div><span>    int *a;</span><br/></div><div><span><span>    size_t size;</span><br/></span></div><div><span><span><span>    size_t cap;</span><br/></span></span></div><div><span><span><span><br/></span></span></span></div><div><span><span><span><span>    int&amp; operator[](  );</span><br/></span></span></span></div><div><br/></div><div><span>    void push_back(int x){</span><br/></div><div><span><span>    <span>    if (++size &gt; cap){</span></span></span></div><div><span><span><span><span>    <span>    <span>    // needs to do some work</span></span></span></span></span></span></div><div><span><span><span><span/><span>    <span>    </span></span>}</span></span></span></div><div><span><span><span><span>    <span>    a [size-1] = x;</span></span><br/></span></span></span></div><div><span><span><span><span><span><br/></span></span></span></span></span></div><div><span><span>    </span>}</span></div><div>}</div><div><br/></div><div><br/></div><div>///////////////////////</div><div>foo()</div><div>{</div><div><span>    IntArray ia;</span></div><div><span><span>    while (1){</span><br/></span></div><div><span><span><span>    <span>    int x;</span></span></span></span></div><div><span><span><span><span><span><span>    </span>    scanf(“%d”, &amp;x);</span><br/></span></span></span></span></div><div><span><span><span><span><span><span>    <span>    ia.push_back(x);</span></span><br/></span></span></span></span></span></div><div><span><span><span><span><span><span><span><span>    <span>    if (x&lt;0) break;</span></span><br/></span></span></span></span></span></span></span></div><div><span><span><span>    </span>}</span></span></div><div><span><span><br/></span></span></div><div><span><span><span>    for (int i = 0 ; ia.size(); i++){</span><br/></span></span></div><div><span><span><span><span>    <span>    cout &lt;&lt; ia[i];</span></span></span></span></span></div><div><span><span><span><span>    </span>}</span></span></span></div><div>}</div><div><br/></div><div><br/></div><div><br/></div><div>//////////////////////</div><div><br/></div><div>template &lt;typename T&gt;</div><div>class vector{</div><div>    T *a;</div><div>    size_t size;</div><div>    size_t cap;</div><div><br/></div><div>    T&amp; operator[](  );</div><div><br/></div><div>    void push_back(T x){</div><div>        if (++size &gt; cap){</div><div>            // needs to do some work</div><div>        }</div><div>        a [size-1] = x;</div><div><br/></div><div>    }</div><div>}</div><div><br/></div><div>/////////////////</div><div>vector &lt;int&gt; v;</div><div><ul><li>you have to tell </li></ul><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>pushback is <b>amortized</b> O(1). O(n) reallocation gets spread out over all of them when you double the capacity every time it’s reached.</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>Vector &lt;MS &gt; v;</div><div>MS s1(“abc”);</div><div>v.push_back(s1);</div><div>v.push_back(s1);</div><div><ul><li>s1 data gets copied</li></ul></div><div>v.push_back(“xyz”);</div><div><ul><li>since the constructor of MS converts char *, the compilor temproarily makes an MS object with “xyz” to pass into push_back</li></ul></div><div><br/></div><div><br/></div><div><br/></div><div>&amp;v[0] does this point to a variable on the stack or heap?</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><ul/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div>"
    }
  ]
}
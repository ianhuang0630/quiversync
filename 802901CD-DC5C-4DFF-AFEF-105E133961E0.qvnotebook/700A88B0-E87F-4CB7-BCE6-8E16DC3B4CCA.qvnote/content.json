{
  "title": "Mar 20",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; white-space: normal;\"><div>Exams:</div><div><ul><li>fork exec</li><li>tcp ip</li></ul></div><div>Would be helpful to start working on lab 5</div><div><br/></div><div>to write a bash script:</div><div><br/></div><div>#!/bin/bash</div><div>ls </div><div>ls </div><div>ls </div><div><ul><li>you must give the file executable permission</li></ul><div><br/></div></div><div><br/></div><div>make sure you understand how pipelines work. </div><div>cat mypipe | nc -l some_port_num | /some … &gt; mypipe</div><div><br/></div><div><br/></div><div><hr/><div><span style=\"font-weight: bold;\">Sockets API</span></div></div><div><br/></div><div>open vs. fopen</div><div><ul><li>fopen returns FILE*</li><li>open returns an integer (<span style=\"font-weight: bold;\">file descriptor</span>). You pass it into ‘read’ and ‘write’ and things like that</li><li>when starting up program, 0,1,2 are automatically generated to stand for the standard input  stand error and stand out.</li></ul><div><br/></div></div><div>socket() returns an integer, and it’s the next <span style=\"font-style: italic;\">untaken</span> integer (0,1,2 are by default taken)</div><div>fopen is a wrapper function for open — the internals of fopen uses file descriptors</div><div><br/></div><div>  1 #include &lt;stdio.h&gt;</div><div>  2 #include &lt;assert.h&gt;</div><div>  3 #include &lt;arpa/inet.h&gt;</div><div>  4</div><div>  5 #define HOST_FILE &quot;endian-demo.host&quot;</div><div>  6 #define NET_FILE  &quot;<a href=\"http://endian-demo.net\">endian-demo.net</a>&quot;</div><div>  7</div><div>  8 int main()</div><div>  9 {</div><div> 10     FILE *f;</div><div> 11     unsigned int num_host;</div><div> 12     unsigned int num_net;</div><div> 13</div><div> 14     printf(&quot;Enter a hexadecimal integer: &quot;);</div><div> 15     scanf(&quot;%x&quot;, &amp;num_host);</div><div> 16     printf(&quot;The hex number 0x%.8x is %d in decimal\\n&quot;, num_host, num_host);</div><div> 17</div><div> 18     f = fopen(HOST_FILE, &quot;wb&quot;);</div><div> 19     assert(f);</div><div> 20     fwrite(&amp;num_host, sizeof(num_host), 1, f);</div><div> 21     printf(&quot;Wrote num_host to %s\\n&quot;, HOST_FILE);</div><div> 22     fclose(f);</div><div> 23</div><div> 24     num_net = htonl(num_host);</div><div><ul><li>htonl takes an integer and either flips all the bytes or do nothing. If that function runs on little endian machines, it would flip the bytes</li><li>“host to order”</li></ul></div><div> 25</div><div> 26     f = fopen(NET_FILE, &quot;wb&quot;);</div><div> 27     assert(f);</div><div> 28     fwrite(&amp;num_net, sizeof(num_net), 1, f);</div><div> 29     printf(&quot;Wrote num_net to %s\\n&quot;, NET_FILE);</div><div><ul><li>writes in the right order.</li></ul></div><div> 30     fclose(f);</div><div> 31</div><div> 32     printf(&quot;Run \\&quot;hd &lt;filename&gt;\\&quot; to see the content of a file\\n&quot;);</div><div><ul><li>hd dumps the raw bytes of the file</li><li>run hd  endian-demo.host </li><ul><li>you will find the number is reversed</li><li>this is what intel processors do. The byte orders are all flipped for native integers. These are called “little endian machines”. The ones that store them in order are “big endian machines” or “Network Byte order”.</li><li>Normally this doesn’t matter, because these are internal representations. Everything acts as if all the bits are in the right order. But when you transfer data from a little endian to a network byte order, this is a problem. </li><ul><li>to fix this problem, when writing out to an external device, everyone agrees to convert to big endian.</li></ul></ul></ul></div><div> 33 }</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div>"
    }
  ]
}
{
  "title": "Feb 8",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; white-space: normal;\"><div>int x = sizeof(a); </div><div><ul><li>x == 40</li></ul><div>x = sizeof℗;</div></div><div><ul><li>x == 8</li></ul></div><div><div><br/></div></div><div><br/></div><div>sizeof(&amp;a[0]):</div><div><ul><li>this is the sizeof the pointer to the first element.</li></ul><div>sizeof(a):</div></div><div><ul><li>not the size of the pointer.</li><li>type of ‘a’ int[10].</li></ul><div><br/></div></div><div>32bit of operating system == address is 4 bytes</div><div>64bit == address is 8 bytes</div><div><br/></div><div>char c[4] = {97, 98, 99, 0};</div><div><ul><li>exactly the same as:</li><ul><li>char c[4]= {‘a’, ‘b’, ‘c’, ‘\\0’};</li></ul><li>when a char array has a 0 at the end, it is used as a string</li><li>this is the string ‘abc’</li><li>equivalent to</li><ul><li>char c[4] = “abc”;</li><ul><li>notice how c[4], not c[3]</li><li>the type of “abc” is char[4]</li><li>“abc” is an expression, but {‘a’, ‘b’, ‘c’, ‘\\0’} isn’t.</li></ul></ul></ul><div>char *p;</div></div><div>p = “abc”;</div><div><ul><li>legal.</li><li>type of p is char *, “abc” is char[4]</li><ul><li>there is a well-defined conversion between types</li><li>“abc” becomes pointer to the first element in the array</li></ul></ul><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div>Given an expression, write down the type of that expression, and if that type is an integer or char, write down the value</div><div>*(“abc” + 1) +1 == ‘c’</div><div><ul><li>“abc” char[4] —&gt; char * pointing to “a&quot;</li><li>(“abc” + 1) —&gt; char * pointing to “b&quot;</li><li>*(“abc” + 1 ) —&gt; char *</li><li>*(“abc” + 1 ) + 1 —&gt; ‘b’ + 1 —&gt; ‘c’</li><li>the resulting value is 1, type int</li></ul><div><br/></div></div><div><br/></div><div><br/></div><div>the string variables are immutable, because they are stored with your code.</div><div>p points to a region pointing to some part of the “code” section of the virtual memory, [“a”, “b”, “c”, 0]</div><div><br/></div><div><ul><li>when an array is anonymous, it stored in the code section</li><ul><li>e.g. p = “abc”</li></ul><li>when it is not anonymous (given its own name), it’s a stack variable.</li></ul><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><hr/><br/></div><div>foo(){</div><div><span>    char t[4];</span></div><div><span>    </span>char *s = “abc”; </div><div><span>    strcpy(t, s);</span></div><div><ul><li>t is going to be a pointer, and s is already a pointer, pointing to an anonymous array</li></ul></div><div><ul/><div><span>    printf(“%s”, t)</span><br/></div></div><div><ul><li>%s: expects a char * as an argument</li><li>it will print out every element in the array until it sees a 0</li></ul></div><div>} </div><div><br/></div><div><br/></div><div><br/></div><div>void strcpy(char *t, char *s){</div><div><span>    while ((*t = *s)!=0) {</span><br/></div><div><ul><li>could be (while (*t++ = *s++) != 0); but makes the pointer one after the 0. THIS IS AN IDIOM IN C. USE IT.</li><li>could be (while (*t++ = *s++));</li></ul><br/><ul><ul/></ul></div><div><span><span><span>    <span>    t ++;</span></span></span></span></div><div><span><span><span>    <span>    </span></span>s ++;    </span></span></div><div><span><span>    </span>}</span></div><div><ul/></div><div>}</div><div><ul><li>THE POINTERS ARE SEPARATE</li><li>copies every element until 0 is copied. terminate after 0 has been copied.</li></ul></div><div><br/></div><div><br/></div><div><br/></div><div>{</div><blockquote style=\"margin: 0 0 0 40px; border: none; padding: 0px;\"><div>char *t = malloc(4);</div></blockquote><div><ul><ul><li>points to 4 <b>bytes</b> on the heap</li><li>malloc returns a pointer to the first element</li><li><b>malloc returns a void *. </b>This allows it to be converted to anything</li></ul></ul></div><div><ul/></div><blockquote style=\"margin: 0 0 0 40px; border: none; padding: 0px;\"><div>char *s = “abc”;</div><div>strcpy(t, s);</div><div>….</div><div><br/></div><div>free(t);</div><div><ul><li>frees the memory in heap</li><li>you could also return t to continue using the array</li></ul></div></blockquote><div>}</div><div><ul><li>Without free(), The heap remains in the memory, even when you’ve lost your pointer.</li><li>This is called memory leak.</li><li>the point of malloc is to create an array</li><li>there might be holes inside the heaps  </li></ul></div><div><br/></div><div><ul/></div><div><br/></div><div><hr/><br/></div><div>COMMAND LINE ARGUMENTS</div><div><br/></div><div>in the terminal:</div><div><font face=\"Courier New\">a.out abc hello</font></div><div><br/></div><div>int main(int argc, char **argv){</div><div><div><div><span>    <span>  // for argv</span></span><br/></div><ul><li>first element is pointer to array holding a.out</li><ul><li>pointer to “a.out” is char *</li><li>a variable that points to first element holding a pointer is type char**</li></ul><li>second element is pointer to array holding abc</li><li>third element is pointer to array holding hello</li><li>fourth element is 0</li></ul></div></div><div><span>    <span>  // for argc</span></span></div><div><ul><li>this is 3</li></ul></div><div><br/></div><div>}</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>argv ++’</div><div>while (*argv){</div><div><span>    printf(“%s”, *argv++)</span><br/></div><div>}</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div>"
    }
  ]
}
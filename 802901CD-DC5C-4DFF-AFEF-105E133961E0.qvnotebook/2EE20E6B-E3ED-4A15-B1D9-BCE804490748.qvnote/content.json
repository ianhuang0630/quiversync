{
  "title": "Mar 6",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; white-space: normal;\"><div><font style=\"font-size: 48px;\"><span style=\"font-size: 48px; font-weight: bold;\">fork + exec</span></font></div><hr/><div><br/></div><div>user ID’s, under the hood, are numbers</div><div>every process has an ID</div><div><br/></div><div>root is user id 0, which is a special user. otherwise, no distinction between users</div><div><br/></div><div>file descriptors  - small integers representing open files</div><div>when a program starts, kernal opens 3 files without being asked</div><div><ul><li>stdin, stdout, stderr = 0,1,2</li></ul><div><br/></div></div><div>int fd = open(“myfile”, O_RDONLY, 0);</div><div><ul><li>int fd “file descriptors”</li><li>open is a low-level API</li><li>the first 3 file descriptors that get open is the standard IOE</li><li>file descriptors start at 0</li></ul><div><br/></div></div><div>Things are represented as a file in unix. even speakers are represented as fake files.</div><div>If you open the file and write some waveform data to the file, the speaker will play the wave</div><div>Unix treats everything that looks remotely like a file as a file</div><div><br/></div><div>You don’t see the file descriptors, because you see FILE * (handles)<br/><br/></div><div><b>Programs and Processes</b></div><div>A process is created by fork &amp; exec by an existing process</div><div><br/></div><div>getpid(): return process ID of the program you’re running</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>int i;</div><div>pid_t p;</div><div>// there is only one process here</div><div>p = fork();</div><div><ul><li>returns a process ID</li><li>System calls. These are special library functions that can’t be easily written, but tell operating to do something special</li><li>it goes deep into the operating system</li><li>It suspense your program</li><li>it clones your program — all of the address space is cloned</li><li>this is how a new process is created in a unix system </li><li>in the parent process, fork returns:</li><ul><li>the child process : new process that got cloned</li></ul><li>in the child process, fork returns 0</li><ul><ul/></ul></ul><div><br/></div><div>// there are two processes here</div></div><div><ul><li>there are two processes, subject to normal operating system scheduling</li><li>Can’t predict the order</li></ul></div><div><br/></div><div>if (p &gt; 0){</div><div><span>    for (i = 0; … ){</span><br/></div><div><span><span><span>    <span>    printf(“Listen to me \\n”);</span></span></span></span></div><div><span><span><span>    <span>    sleep(1);</span></span><br/></span></span></div><div><span><span>    </span>}</span></div><div><span><span>    </span>printf(&quot;I give up&quot;);</span></div><div><span><span>    return 0 ;</span><br/></span></div><div>}</div><div><br/></div><div>else if (p == 0){</div><div><span>    for (i = 0; i&lt;10…){</span><br/></div><div><span><span>    <span>    printf(“No way\\n”);</span></span></span></div><div><span><span><span><span>    <span>    </span></span>sleep(1);</span></span></span></div><div><span><span>    </span>}</span></div><div><span><span>    printf(“Whatever.\\n”)</span><br/></span></div><div><span><span><span>    return 1;</span><br/></span></span></div><div>}</div><div><br/></div><div>else{ // if p &lt; 0</div><div><span>    perror(“fork failed”);</span><br/></div><div><span><span>    </span>return -1;</span></div><div>}</div><div><br/></div><div><b>the above is the sample-code folder. cloneable</b></div><div><br/></div><div><br/></div><div>exec morphs a process into a new program</div><div><br/></div><div>execl(buf, buf, (char*) 0 );</div><div><ul><li>buf - program you want it to run</li><li>buf - argv </li><li>execl will turn its own program into a new program. It doesn’t come back to the previous state.</li><li>process ID remains THE SAME</li></ul></div><div><br/></div><div>waitpid(pid, &amp;status, 0)</div><div><ul><li>Waits until child is done</li><li>pid - the pid of the child process<br/></li><li>&amp;status - to record the exit status of the child in integer variable status</li><ul><li>stores the return of the main of the child process</li></ul></ul></div><div><br/></div><div>pid = fork();</div><div><br/></div><div>if (pid&lt;0){</div><div><span>    die (“Fork error”);</span><br/></div><div>} else if (pid == 0){</div><div><span>    execl (buf, buf, (char *) 0 );</span><br/></div><div><span><span>    </span>die (“execl failed”); </span></div><div>} else {</div><div><span>    // parent rpocess</span><br/></div><div><span><span>    if (waitpid(pid, &amp;status, 0) != pid)</span><br/></span></div><div><span><span><span>    <span>    die (“”)</span></span><br/></span></span></div><div>}</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>if the parent process writes to a global variable, it doesn’t affect the child because it has its own global variable</div><div><br/></div><div><hr/><br/></div><div>nc -l 12345</div><div><ul><li>nc </li><li>-l for listening mode</li></ul><div><br/></div></div><div>nc <a href=\"http://clac.cs.columbia.edu\">clac.cs.columbia.edu</a> 12345</div><div><ul><li>anything you type now will show up on the other computer</li></ul><div><br/></div></div><div>TCP connection is 2-way. </div><div><br/></div><div><ul/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div>"
    }
  ]
}
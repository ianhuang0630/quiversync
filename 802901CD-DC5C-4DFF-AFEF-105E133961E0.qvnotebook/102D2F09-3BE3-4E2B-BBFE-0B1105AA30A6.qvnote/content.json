{
  "title": "Feb 1",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; white-space: normal;\"><div>Lecture notes 4 + 5</div><div><ul><li>are on pointers</li></ul><div><br/></div></div><div>Lecture notes 2 today</div><div><br/></div><div>#ifndef __MYADD_H__</div><div>#define __MYADD_H__</div><div>int myadd(int x, int y);</div><div>#endif</div><div><ul><li>“#” — preprocessing directive, read during preprocessing</li><ul><li>e.g. #include &lt;stdio.h&gt;</li></ul><li>#define</li><ul><li>e.g. #define PI 3.14</li><li>e.g.</li><ul><li>#define sqr(x) x*x</li><li>… </li><li>sqrt(3*3)</li><ul><li>it’s not quite search and replace like the first example</li></ul></ul><li>#define defines __MYADD_H__ to be nothing</li><li>#ifndef — if not defined</li></ul><li>THis is useful in case something gets #include’ed twice</li><li>One header file might include another headerfile, and could be circular!</li><li>Avoids compilation time in huge projects.</li><li>__MYADD_H__ could be replaced by any string. it just has to be unique.</li></ul><div><br/></div></div><div>#define sqr(x) x*x</div><div><ul><li>calling a function can be expensive. So if it happens all the time, (e.g. in a loop), some programmers would prefer using a <span style=\"font-weight: bold;\">macro</span></li><li><span style=\"font-weight: bold;\">foo(){ y = sqr(3+4);}</span></li><ul><li><span style=\"font-weight: bold;\">would replace sqr(…) with 3+4 * 3+4</span></li></ul><li>Discouraged to use macro in the class</li><li>the proper way to use macro’s is to parenthesize everything i.e. sqr(x) ((x)*(x))</li></ul><div><hr/></div><div><span style=\"font-weight: bold; font-size: 24px;\">MEMORY SPACE</span></div><div><ul><li>space from index 0 to 512G</li><li>At the very bottom at address 0 is not used. </li><li>At the bottom of the space is <span style=\"font-weight: bold;\">code</span></li><li>Moving up, <span style=\"font-weight: bold;\">static variables </span></li><ul><li>global static</li><li>file static</li><li>function static</li></ul><li><span style=\"font-weight: bold;\">Code + static variables </span>= size of program</li><li>Moving up is Heap.</li><li>At the very top, Automatic (local, stack) variables are stored in the “stack” portion of the memory</li><li>size of stack and size of heap grows and shrinks</li></ul><div><br/></div></div><div><br/></div><div><span style=\"font-weight: bold;\">How stack grows and shrinks</span></div><div><br/></div><div><span style=\"font-weight: bold;\">int f(int x){</span></div><div><span style=\"font-weight: bold;\">    int y;    </span></div><div><span style=\"font-weight: bold;\">    if (x&gt;1) {</span></div><div><span style=\"font-weight: bold;\">        y = x * f(x-1);</span></div><div><span style=\"font-weight: bold;\">        return y;    </span></div><div><span style=\"font-weight: bold;\">    }</span></div><div><span style=\"font-weight: bold;\">    else</span></div><div><span style=\"font-weight: bold;\">        return 1;</span></div><div><span style=\"font-weight: bold;\">}</span></div><div><br/></div><div><ul><li><span style=\"font-weight: bold;\">recursive implementation of factorial function</span></li></ul><div><br/></div></div><div>f(3)</div><div><ul><li>x =3</li><li>f(2)</li><ul><li>x = 2</li><li>f(1) </li><ul><li>returns 1</li></ul><li>returns 2*1</li></ul><li>returns 3*2</li></ul><div><br/></div></div><div>during first invocation of f, x and y first get allocated into the stack.</div><div><br/></div><div>during second invocation of f, x and y are brand new and get allocated into the stack. The stack will grow downwards (lower and lower memory indices)</div></div><div><br/></div><div>As the stack grows, the CPU keeps track of where the bottom of the stack is. The varaible for keeping track of this is the <span style=\"font-weight: bold;\">“stack pointer”</span></div><div><br/></div><div><span style=\"font-weight: bold;\">When returning from f(1), the stack pointer will roll up and leave out the stack memory used by f(1).</span></div><div><br/></div><div><span style=\"font-weight: bold;\">You wont’ ever want to “Remove” memory in the middle of a stack. that’s why it’s a stack.</span></div><div><hr/></div><div><br/></div><div><span style=\"font-weight: bold; font-size: 24px;\">POINTERS</span></div><div><br/></div><div>int x = 1, y = 2;</div><div>int *p;</div><div><ul><li>int * is the type NOT int.</li><li>aka</li><ul><li>int *</li><li>pointer to int</li><li>address of int</li></ul><li>Contains the memory address of another variable. They are still numbers</li><li>int* p also works! But it’s customary to write it as int *p</li><ul><li>int *p means “if you apply * to p, then you get back int.” (see below)</li></ul></ul><div><br/></div></div><div>p = &amp;x;</div><div><ul><li>&amp;x — address of x</li><li>&amp; is a unary operator</li><li>p = 2000</li><li>Resulting type of &amp;x</li><ul><li>is whatever type of x + *</li><li>int *</li></ul><li>&quot;p is a pointer variable that points to x”</li></ul><div><br/></div><div>y = *p;</div><ul><li><span style=\"font-weight: bold;\">*p</span></li><ul><li>Takes an address of an existing variable and goes in there and grabs what it’s pointing to.</li><li>Type of p is int *</li><li>* [variable *]</li><ul><li>becomes of type [variable]</li><li>A star operator on something that isn’t a star variable is a syntax variable</li></ul></ul></ul><div><br/></div></div><div>*p = 0;</div><div><ul><li>changes x to 0</li><li>it does not change y.</li></ul><div><br/></div></div><div>(</div><div>scanf(  , &amp;x)</div><div><ul><li>takes the address of a variable so that inside the function, it can go to &amp;x and change it. If a variable is passed, scanf can’t do anything with that value.</li></ul><div>)</div></div><div><br/></div><div>p = &amp;y;</div><div><ul><li>Reassigning p to the address of y</li></ul><div><br/></div></div><div><div><div> *p = 2;</div><div><div><br/></div><div>++*p ;</div><div><ul><li>y would become 3</li></ul></div><div><div>(*p)++;</div><div><ul><li>y would become 4</li><li>It doesn’t matter</li><li>*p ++ == *(p++)</li><ul><li>incrementing pointer itself. </li></ul></ul><div><br/></div></div><div>PRECIDENCE OF OPERATIONS:</div><div><ul><li><input type=\"checkbox\" checked=\"false\"/>page 53</li></ul></div><ul/></div><ul/></div><div><br/></div><ul/></div><table style=\"border-collapse: collapse; min-width: 100%;\"><colgroup><col style=\"width: 130px;\"/><col style=\"width: 130px;\"/><col style=\"width: 334px;\"/></colgroup><tbody><tr><td style=\"border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;\"><div>Location</div></td><td style=\"border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;\"><div>Var</div></td><td style=\"border: 1px solid rgb(219, 219, 219); width: 334px; padding: 8px;\"><div>Val</div></td></tr><tr><td style=\"border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;\"><div>2000</div></td><td style=\"border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;\"><div>x</div></td><td style=\"border: 1px solid rgb(219, 219, 219); width: 334px; padding: 8px;\"><div>1 -&gt; 0 </div></td></tr><tr><td style=\"border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;\"><div>1996 (4 bytes bellow)</div></td><td style=\"border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;\"><div>y</div></td><td style=\"border: 1px solid rgb(219, 219, 219); width: 334px; padding: 8px;\"><div>2 —&gt; 1 —&gt; 2 —&gt; 3 —&gt; 4</div></td></tr><tr><td style=\"border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;\"><div>1988</div></td><td style=\"border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;\"><div>p</div></td><td style=\"border: 1px solid rgb(219, 219, 219); width: 334px; padding: 8px;\"><div>2000 —&gt; 1996</div></td></tr><tr><td style=\"border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;\"><div><br/></div></td><td style=\"border: 1px solid rgb(219, 219, 219); width: 130px; padding: 8px;\"><div><br/></div></td><td style=\"border: 1px solid rgb(219, 219, 219); width: 334px; padding: 8px;\"><div><br/></div></td></tr></tbody></table><div><br/></div></div><div><br/></div><div><br/></div><div>double d = 3.14;</div><div>double *pd = &amp;d;</div><div><ul><li>a pointer variable that points to a double variable</li><li>double * and int * are distinct types.</li></ul><div>int i = 3;</div></div><div>int *pi = &amp;i;</div><div><br/></div><div>pi = pd</div><div><ul><li>would yield a compiler error, inconsistent types.</li></ul><div><br/></div></div><div>pi = (int *) pd;</div><div><ul><li>casting — change the variable type forcefully</li><li>*pi would get a number from the first 4 bytes from the 8bytes stored at pd.</li><li>*pi would be some random thing.</li></ul><div><br/></div><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div></div>"
    }
  ]
}
{
  "title": "Apr 10",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; white-space: normal;\"><div>class Pt{</div><div>public:</div><div>    double x;</div><div>    double y;</div><div>    Pt (double _x, double _y) {</div><ul><li>this is a constructor. you can initialize your object with fields.</li></ul><div>        x = _x; y = _y;</div><div>    }</div><div>    </div><div>    Pt (double _x = 10, double _y = 10){</div><ul><li>this gives default values if any of them are not given.</li><li>you can initialize this </li><li>but you can’t use the default value for x but then specify soemthing for y….</li></ul><div>        x = _x;</div><div>        y= _y;    </div><div>    } </div><div><br/></div><div>    void print(){</div><div>        cout &lt;&lt; “(” &lt;&lt; x &lt;&lt; “,” &lt;&lt; y &lt;&lt; “)”&lt;&lt; endl;</div><div>        </div><div>        cout &lt;&lt; “(” &lt;&lt; this -&gt; x  &lt;&lt; “,” &lt;&lt; this -&gt; y &lt;&lt; “)” &lt;&lt; endl ;</div><div>    }</div><div><br/></div><div><br/></div><div><span>    </span>~Pt(){</div><div><ul><li>called when stack variables goes out of scope</li><li>At the end of the main function, p1 goes out of scope, and so this function will be called</li><li><b>you can clean things up here — free mallocs…etc</b></li></ul></div><div><span>    <span>    cout &lt;&lt; “bye now” &lt;&lt; endl;</span></span><br/></div><div><ul/></div><div><span><span>    </span>}</span></div><div>}</div><div><br/></div><div>int main(){</div><div><span>    Pt pt1 (20);</span><br/></div><div><ul><li>don’t need to put ‘struct’</li><li>in C++ — if you write the constructor, it will get called for you and youw ill get a pointer to that memory via “this”. </li></ul><div><br/></div></div><div><span>    {</span></div><div><span><span>    <span>    </span></span>Pt p1;</span></div><div><ul><li>this p1 and the previous p1 have nothing to do with eachother because in different scopes</li></ul></div><div><span>   <span>    </span> p1.print(); <b>// will print (10,10)</b></span></div><div><ul/></div><div><span>    </span>} // <b>this will trigger p1’s destruction — will print “bye now”</b><br/></div><div><b><br/></b></div><div><b>    </b>p1.print(); <b>// will print (20, 10)</b><br/></div><div>    <br/></div><div>}<b>// this will trigger p1’s destruction — will print “bye now”</b></div><div><hr/></div><div><br/></div><div><b><br/></b></div><div>void transpose(Pt p){</div><div><div><ul><li>this will not change the structure of a Pt object  passed in — this is because the object is replicated. </li><li>It’s being passed by value.</li></ul></div><ul/></div><div>    double t = p.x;</div><div>    p.x = p.y; </div><div>    p.y = t;</div><div>}</div><div><br/></div><div><br/></div><div><hr/></div><div><br/></div><div>Pt&amp; p</div><div><ul><li>a reference</li><li>C++ has passing by reference</li><ul><li>different from passing by value in C</li></ul></ul></div><div><ul><li>you could also put Pt &amp;p, but that’s confusing</li><li>this would give the same behavior as if you passed a pointer</li></ul><div><br/></div></div><div><br/></div><div><br/></div><div>void transpose(Pt&amp; p){</div><ul><li>this will not change the structure of a Pt object  passed in — this is because the object is replicated. </li><li>It’s being passed by value.</li></ul><div>    double t = p.x;</div><div>    p.x = p.y; </div><div>    p.y = t;</div><div>}</div><div><br/></div><div>Pt(const Pt&amp; orig){</div><div><div><ul><li>Pt&amp; is needed. Pt wouldn't’ work, cuz that would still be passing by value, and it would have been copied anyways.</li><li>If you specify a copy constructor like this, the compiler wouldn’t provide you with a default one.</li><li>const — promises that will not modify orig</li></ul></div><ul/></div><div><span><span>    </span>x = orig.x;</span><br/></div><div><span><span>    y = orig.y;</span><br/></span></div><div><span><span><span>    </span><br/></span></span></div><div>}</div><div><br/></div><div>int main(){</div><div><span>    Pt p1(20);</span><br/></div><div><span><span>    </span>transpose(p1);</span></div><div><span><span>    </span>p1.print();</span></div><div>}</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>you do passing by construction, the compilor doesn’t call the constructor under the class. it would use a copy constructor to copy over the fields. The copy constructor is provided by compiler. This is the same as what happens in C. </div><div><br/></div><div><br/></div><div>the copy constructor is also called when you are <b>returning</b> by value. </div><div><br/></div><div><br/></div><div><br/></div><div>So when transpose is finished, two deconstructions will happen — the input and the return value, since they were copied.</div><div><br/></div><div><br/></div><div><br/></div><div>Pt&amp; operator=(const Pt&amp; rhs){</div><div><div><ul><li>written as a method</li><li>called when a Pt object is assigned to another</li><li>needs to return Pt&amp; — the value of the expression (A=B). It can’t return Pt, since it would be a copy. </li></ul></div><ul/></div><div><span>    x = rhs.x;</span><br/></div><div><span><span>    y = rhs.y;</span><br/></span></div><div><span><span><span>    cout &lt;&lt; “assigned” &lt;&lt; endl;</span><br/></span></span></div><div><span><span><span><span>    </span><br/></span></span></span></div><div><span><span><span><span><span>    return *this;</span><br/></span></span></span></span></div><div><ul><li>‘this’ pointer is the wrong type to return, must dereference.</li></ul></div><ul/><div>}</div><div><br/></div></div>"
    }
  ]
}
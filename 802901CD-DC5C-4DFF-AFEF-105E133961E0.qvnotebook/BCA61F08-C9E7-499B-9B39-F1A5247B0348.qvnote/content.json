{
  "title": "Feb 6",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; white-space: normal;\"><div>Int *p;</div><div>double  *q;</div><div>p = q; // this will not compile</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>int *p = &amp;x;</div><div>double *q = &amp;y;</div><div>p = (int *) q;</div><div><ul><li>reinterpret double * p as an int *</li></ul></div><div><br/></div><div><br/></div><div><br/></div><div>void *r ;</div><div>r = p;</div><div><ul><li>no casting needed</li></ul><div>q = r;</div></div><div><ul><li>no casting needed</li></ul><div>int x = *r ;</div></div><div><ul><li>does not compile</li><li>r doesn’t have type information, it doesn’t have the information to extract the appropriate number of bits</li></ul><div>int x = *(int*)r;</div></div><div><ul><li>this does compile</li><li>cast first, and then dereference.</li></ul><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>int *p = 0;</div><div><ul><li>called a null pointer</li><li>contains the 0 address</li></ul><div><br/></div></div><div>p  = NULL;</div><div><ul><li>in some headerfile…</li><li>#define NULL 0</li><li>#define NULL ((void*) 0)</li><li>it’s an address, not the number 0</li></ul><div><br/></div><div>Any attempt to dereference a null pointer will cause…</div><div>a segmentation fault will be caused, and program will crash.</div><div><br/></div><div><br/></div><div>if (p){</div><div>    printf(“p is not a null pointer.”);</div><div>}</div><div><br/></div><div>char c = 0;</div><div>char *p = &amp;c;</div><div>if (p) {</div><div>    // this will print, because p is not the null pointer. c holds 0.</div><div>    printf(“This is always true.”);</div><div>}</div></div><div>if (*p){</div><div>    // this will not print, because *p points to the value 0.</div><div>}</div><div><br/></div><div><br/></div><div><br/></div><div>char *q = 0;</div><div>if (q){</div><div>    // will never execute</div><div>}</div><div>if (*q)</div><div><ul><li>will crash your program</li></ul><div><br/></div></div><div><br/></div><div><br/></div><div><b><font style=\"font-size: 36px;\">Arrays</font></b></div><div><hr/>how arrays relate to pointers<br/><div><br/></div></div><div>{</div><div>int x;</div><div>int a [10] = {100,101,102 …… 109} ; // gives space in the stack</div><div><ul><li>guarantees that those 10 elements would be allocated to a contiguous region of memory</li><li>addresses 2000, 2004, 2008…</li><ul><li>the next thing you declare would start at a lower address, but the addresses within that thing will go up.</li></ul></ul></div><div>double b [2];</div><div>double y = b[2];</div><div><ul><li><b>No index out of bounds error.</b></li><li><b>YOU WOULD ACCESS A BLOCK OF MEMORY ABOVE WHAT’S BEEN DEDICATED TO B.</b></li></ul></div><div>printf(“%d”, a[9]);</div><div><ul/></div><div>printf(“%d”, sizeof(a));</div><div><ul><li>byte-size of a</li></ul><div><br/></div></div><div>int *p = &amp;a[0]; // &amp;(a[0])</div><div><ul><li>p points to 2000, since lets just say that’s where a[0] is</li></ul><div>int *q;</div></div><div>q = p +1; // same as q  =  &amp;a[0] + 1;</div><div><ul><li>DOES NOT MEAN adding one to the address</li><li>Adding the size of the element that p is pointing to</li><ul><li>p+1 would change the address by adding sizeof(*p)</li></ul><li>q = 2000 + 4   —&gt;   q = 2004</li><li>Adding one to the pointer is the address of the next element in the array</li><li>Even if *p weren’t in the list, incrementing p by 1 would be changing the address by the same amount.</li></ul></div><div>}</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>for (i = 0; i &lt; 10; i ++){</div><div><span>    printf(“%d”, a[i]);</span></div><div><span><span>    printf(“%d”, *(p+i));</span><br/></span></div><div><ul><li>    same thing<br/></li></ul><div><span>    </span><br/></div></div><div><span><span>    printf(“%d”, *p);</span><br/></span></div><div><span><span><span>    p++;</span><br/></span></span></div><div><div><br/></div></div><div><span>    printf(“%d”, *p++);</span></div><div><ul><li>++ binds more tightly than *</li><li>++ has higher precedence than *</li></ul><div><span><br/></span></div><div>    <br/></div></div><div><span>}</span></div><div><span><br/></span></div><div><br/></div><div><br/></div><div>a + 1 // same thing as &amp;a[1]</div><ul><li>name of an array a will become &amp;a[0] in most contexts.</li><ul><li>EXCEPTION: sizeof(a)</li></ul><li>a is NOT a pointer. But it will be interpreted as the pointer to the first element in most contexts.</li></ul><div><br/></div><div>int *p = &amp;a[0];</div><div>*(a+1) // same thing as *(&amp;a[1])</div><div><ul><li>would have value of a[1]</li><li>would have same value as *(p+1)</li></ul></div><div>p[1] // same as *(p+1)</div><div><ul><li>you can use pointers as if they’re an array</li></ul></div><div><br/></div><div>a++ <b>does not work.</b> a is not a variable it’s a name.</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>Grand unified theory:</div><div><ul><li>*(x+y) = x [y]</li></ul>relationship always holds.</div><div><br/></div><div>0[a]  ==&gt; *(0+a) ==&gt; *(a+0) ==&gt; a[0]</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div>"
    }
  ]
}
{
  "title": "Untitled Note",
  "cells": [
    {
      "type": "code",
      "language": "assembly_x86",
      "data": "AddandVerify:\n    lw $t0, 0($a0)\n    ; if is base case, branch to B2\n    beq $t0, $zero, B2\n    ; else, continue\n    ; storing variable in stack\n    sw $a0, -4($sp)\n    sw $a1, -8($sp)\n    sw $a2, -12($sp)\n    sw $t0, -16($sp)\n    sw $ra, -20($sp)\n    addi $sp, $sp, -20 ; shifting the stack pointer\n    ; recursive call\n    addi $a0, $a0, 4 ; replacing a0\n    addi $a1, $a1, 4 ; replacing a1\n    jal AddandVerify ; replacing ra\n    ; $v0 and $v1 now contain validity and carry, respectively\n    \n    ; reloading variables from stack\n    lw $ra, 0($sp)\n    lw $t0, 4($sp)\n    lw $a2, 8($sp)\n    lw $a1, 12($sp)\n    lw $a0, 16($sp)\n    addi $sp, $sp, 20 ; shifting the stack pointer back\n    \n    ; check v0 = 1\n    beq $v0, $zero, B3\n    \n    ; given that the section is valid\n    ; storing variables\n    sw $ra, -4 ($sp)\n    ; sw $v0, -24($sp) ; will be overwritten by Word Decrypt, storing \n    ; sw $v1, -28($sp) ; will be overwritten by Word Decrypt, sotring \n    ; storing $v0 and $v1\n    addi $sp, $sp, -4 ; shifting the stack pointer\n    \n    ; Word Decrypt call\n    add $a0, $zero, $t0 ; replacing a0\n    add $a1, $zero, $a2 ; key put into a1\n    add $a2, $zero, $v1 ; carry put into a2\n    jal WordDecrypt ; replacing ra\n    ; $v0 and $v1 are decrypted and carry, respectively. This carry should be what's returned in the end\n    ; next, we check if $v0 is a corerct candidate\n    add $a0, $zero, $v0 ; replacing a0 again\n    jal IsCandidate ; replacing ra\n    ; $v0 indicates whether the expression is valid \n    \n    ; by now $v0 is 1 if the whole string is valid, and $v1 is the cary from WordDecrypt\n    \n    ; restore ra \n    lw $ra, 0($sp)\n    addi $sp, $sp, 4\n    \n    ; jump return to whatever called the function\n    jr $ra\n\nB2: ; handles the base case\n    addi $v0, $zero, 1  ;setting v0 to 1, zero string valid by default\n    sw $zero, 0($v1) ;saving writing the decryption of 0, which is 0, to address at $v1\n    add $v1, $zero, $zero ;carry $v1 is 0 by default.\n    jr $ra\n\nB3: ; if $v0 = 0 (i.e. ending is invalid), or current \n    add $v0, $zero, $zero\n    add $v1, $zero, $zero ; doesn't matter what the carry is if it's 0.\n    ; TODO\n    \n    jr $ra\n\n\nWordDecrypt:\n    addi $t2, $zero, 0\n    add $t1, $a0, $a1\n    add $v0, $t1, $a2\n    \n    add $v1, $t2, $zero ; initializing carry to 0\n    sub $t3, $a1, $v0\n    bgtz $t3, L1 ; if input is greater than sum, then we know there is an error\n    ; jump back to caller\n    jr $ra\n    \nL1: \n    add $v1, $v1, 1 ; changing carry to 1\n    ; jump back to caller\n    jr $ra\n\n\nIsCandidate:\n    add $t4, $a0, $zero ; making a copy of $a0\n    addi $v0, $zero, 1 ; preliminarily say yes\n    \n    ; check 1\n    andi $t1, $t4, 255\n    sub $t2, $t1, 90\n    add $t3, -$t1, 64\n    bgtz $t2, L2\n    bgtz $t3, L2\n    srl $t4, $t4, 8\n    \n    ; check 2\n    andi $t1, $t4, 255\n    sub $t2, $t1, 90\n    add $t3, -$t1, 64\n    bgtz $t2, L2\n    bgtz $t3, L2\n    srl $t4, $t4, 8\n    \n    ; check 3\n    andi $t1, $t4, 255\n    sub $t2, $t1, 90\n    add $t3, -$t1, 64\n    bgtz $t2, L2\n    bgtz $t3, L2\n    srl $t4, $t4, 8\n    \n    ; check 4\n    andi $t1, $t4, 255\n    sub $t2, $t1, 90\n    add $t3, -$t1, 64\n    bgtz $t2, L2\n    bgtz $t3, L2\n    srl $t4, $t4, 8\n    \n    ; jump back to caller\n    jr $ra\n    \nL2: ; set $v0 = 0\n    add $v0, $zero, $zero \n    jr $ra\n\n\n"
    }
  ]
}